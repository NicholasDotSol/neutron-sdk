// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos_proto/cosmos.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  InterfaceDescriptor describes an interface type to be used with
///  accepts_interface and implements_interface and declared by declare_interface.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos_proto.InterfaceDescriptor)
pub struct InterfaceDescriptor {
    // message fields
    ///  name is the name of the interface. It should be a short-name (without
    ///  a period) such that the fully qualified name of the interface will be
    ///  package.name, ex. for the package a.b and interface named C, the
    ///  fully-qualified name will be a.b.C.
    // @@protoc_insertion_point(field:cosmos_proto.InterfaceDescriptor.name)
    pub name: ::std::string::String,
    ///  description is a human-readable description of the interface and its
    ///  purpose.
    // @@protoc_insertion_point(field:cosmos_proto.InterfaceDescriptor.description)
    pub description: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos_proto.InterfaceDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InterfaceDescriptor {
    fn default() -> &'a InterfaceDescriptor {
        <InterfaceDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceDescriptor {
    pub fn new() -> InterfaceDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &InterfaceDescriptor| { &m.name },
            |m: &mut InterfaceDescriptor| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &InterfaceDescriptor| { &m.description },
            |m: &mut InterfaceDescriptor| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InterfaceDescriptor>(
            "InterfaceDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InterfaceDescriptor {
    const NAME: &'static str = "InterfaceDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InterfaceDescriptor {
        InterfaceDescriptor::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InterfaceDescriptor {
        static instance: InterfaceDescriptor = InterfaceDescriptor {
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InterfaceDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InterfaceDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InterfaceDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ScalarDescriptor describes an scalar type to be used with
///  the scalar field option and declared by declare_scalar.
///  Scalars extend simple protobuf built-in types with additional
///  syntax and semantics, for instance to represent big integers.
///  Scalars should ideally define an encoding such that there is only one
///  valid syntactical representation for a given semantic meaning,
///  i.e. the encoding should be deterministic.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos_proto.ScalarDescriptor)
pub struct ScalarDescriptor {
    // message fields
    ///  name is the name of the scalar. It should be a short-name (without
    ///  a period) such that the fully qualified name of the scalar will be
    ///  package.name, ex. for the package a.b and scalar named C, the
    ///  fully-qualified name will be a.b.C.
    // @@protoc_insertion_point(field:cosmos_proto.ScalarDescriptor.name)
    pub name: ::std::string::String,
    ///  description is a human-readable description of the scalar and its
    ///  encoding format. For instance a big integer or decimal scalar should
    ///  specify precisely the expected encoding format.
    // @@protoc_insertion_point(field:cosmos_proto.ScalarDescriptor.description)
    pub description: ::std::string::String,
    ///  field_type is the type of field with which this scalar can be used.
    ///  Scalars can be used with one and only one type of field so that
    ///  encoding standards and simple and clear. Currently only string and
    ///  bytes fields are supported for scalars.
    // @@protoc_insertion_point(field:cosmos_proto.ScalarDescriptor.field_type)
    pub field_type: ::std::vec::Vec<::protobuf::EnumOrUnknown<ScalarType>>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos_proto.ScalarDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScalarDescriptor {
    fn default() -> &'a ScalarDescriptor {
        <ScalarDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl ScalarDescriptor {
    pub fn new() -> ScalarDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ScalarDescriptor| { &m.name },
            |m: &mut ScalarDescriptor| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ScalarDescriptor| { &m.description },
            |m: &mut ScalarDescriptor| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "field_type",
            |m: &ScalarDescriptor| { &m.field_type },
            |m: &mut ScalarDescriptor| { &mut m.field_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScalarDescriptor>(
            "ScalarDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScalarDescriptor {
    const NAME: &'static str = "ScalarDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                24 => {
                    self.field_type.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.field_type)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.field_type {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.field_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScalarDescriptor {
        ScalarDescriptor::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.field_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScalarDescriptor {
        static instance: ScalarDescriptor = ScalarDescriptor {
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            field_type: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScalarDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScalarDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScalarDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cosmos_proto.ScalarType)
pub enum ScalarType {
    // @@protoc_insertion_point(enum_value:cosmos_proto.ScalarType.SCALAR_TYPE_UNSPECIFIED)
    SCALAR_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:cosmos_proto.ScalarType.SCALAR_TYPE_STRING)
    SCALAR_TYPE_STRING = 1,
    // @@protoc_insertion_point(enum_value:cosmos_proto.ScalarType.SCALAR_TYPE_BYTES)
    SCALAR_TYPE_BYTES = 2,
}

impl ::protobuf::Enum for ScalarType {
    const NAME: &'static str = "ScalarType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ScalarType> {
        match value {
            0 => ::std::option::Option::Some(ScalarType::SCALAR_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ScalarType::SCALAR_TYPE_STRING),
            2 => ::std::option::Option::Some(ScalarType::SCALAR_TYPE_BYTES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ScalarType] = &[
        ScalarType::SCALAR_TYPE_UNSPECIFIED,
        ScalarType::SCALAR_TYPE_STRING,
        ScalarType::SCALAR_TYPE_BYTES,
    ];
}

impl ::protobuf::EnumFull for ScalarType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ScalarType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ScalarType {
    fn default() -> Self {
        ScalarType::SCALAR_TYPE_UNSPECIFIED
    }
}

impl ScalarType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ScalarType>("ScalarType")
    }
}

/// Extension fields
pub mod exts {

    pub const implements_interface: ::protobuf::ext::ExtFieldRepeated<::protobuf::descriptor::MessageOptions, ::std::string::String> = ::protobuf::ext::ExtFieldRepeated::new(93001, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const accepts_interface: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(93001, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const scalar: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(93002, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const declare_interface: ::protobuf::ext::ExtFieldRepeated<::protobuf::descriptor::FileOptions, super::InterfaceDescriptor> = ::protobuf::ext::ExtFieldRepeated::new(793021, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);

    pub const declare_scalar: ::protobuf::ext::ExtFieldRepeated<::protobuf::descriptor::FileOptions, super::ScalarDescriptor> = ::protobuf::ext::ExtFieldRepeated::new(793022, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19cosmos_proto/cosmos.proto\x12\x0ccosmos_proto\x1a\x20google/protob\
    uf/descriptor.proto\"K\n\x13InterfaceDescriptor\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\
    \x0bdescription\"\x81\x01\n\x10ScalarDescriptor\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\
    \x0bdescription\x127\n\nfield_type\x18\x03\x20\x03(\x0e2\x18.cosmos_prot\
    o.ScalarTypeR\tfieldType*X\n\nScalarType\x12\x1b\n\x17SCALAR_TYPE_UNSPEC\
    IFIED\x10\0\x12\x16\n\x12SCALAR_TYPE_STRING\x10\x01\x12\x15\n\x11SCALAR_\
    TYPE_BYTES\x10\x02:T\n\x14implements_interface\x18\xc9\xd6\x05\x20\x03(\
    \t\x12\x1f.google.protobuf.MessageOptionsR\x13implementsInterface:L\n\
    \x11accepts_interface\x18\xc9\xd6\x05\x20\x01(\t\x12\x1d.google.protobuf\
    .FieldOptionsR\x10acceptsInterface:7\n\x06scalar\x18\xca\xd6\x05\x20\x01\
    (\t\x12\x1d.google.protobuf.FieldOptionsR\x06scalar:n\n\x11declare_inter\
    face\x18\xbd\xb30\x20\x03(\x0b2!.cosmos_proto.InterfaceDescriptor\x12\
    \x1c.google.protobuf.FileOptionsR\x10declareInterface:e\n\x0edeclare_sca\
    lar\x18\xbe\xb30\x20\x03(\x0b2\x1e.cosmos_proto.ScalarDescriptor\x12\x1c\
    .google.protobuf.FileOptionsR\rdeclareScalarB-Z+github.com/cosmos/cosmos\
    -proto;cosmos_protoJ\xb0\x1f\n\x06\x12\x04\0\0`\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x15\n\t\n\x02\x03\0\x12\x03\
    \x03\0*\n\x08\n\x01\x08\x12\x03\x05\0B\n\t\n\x02\x08\x0b\x12\x03\x05\0B\
    \n\t\n\x01\x07\x12\x04\x07\0\x0f\x01\n\xb6\x02\n\x02\x07\0\x12\x03\x0e\
    \x041\x1a\xaa\x02\x20implements_interface\x20is\x20used\x20to\x20indicat\
    e\x20the\x20type\x20name\x20of\x20the\x20interface\n\x20that\x20a\x20mes\
    sage\x20implements\x20so\x20that\x20it\x20can\x20be\x20used\x20in\x20goo\
    gle.protobuf.Any\n\x20fields\x20that\x20accept\x20that\x20interface.\x20\
    A\x20message\x20can\x20implement\x20multiple\n\x20interfaces.\x20Interfa\
    ces\x20should\x20be\x20declared\x20using\x20a\x20declare_interface\n\x20\
    file\x20option.\n\n\n\n\x03\x07\0\x02\x12\x03\x07\x07%\n\n\n\x03\x07\0\
    \x04\x12\x03\x0e\x04\x0c\n\n\n\x03\x07\0\x05\x12\x03\x0e\r\x13\n\n\n\x03\
    \x07\0\x01\x12\x03\x0e\x14(\n\n\n\x03\x07\0\x03\x12\x03\x0e+0\n\t\n\x01\
    \x07\x12\x04\x11\0\x1d\x01\n\xd4\x01\n\x02\x07\x01\x12\x03\x16\x04%\x1a\
    \xc8\x01\x20accepts_interface\x20is\x20used\x20to\x20annotate\x20that\
    \x20a\x20google.protobuf.Any\n\x20field\x20accepts\x20messages\x20that\
    \x20implement\x20the\x20specified\x20interface.\n\x20Interfaces\x20shoul\
    d\x20be\x20declared\x20using\x20a\x20declare_interface\x20file\x20option\
    .\n\n\n\n\x03\x07\x01\x02\x12\x03\x11\x07#\n\n\n\x03\x07\x01\x05\x12\x03\
    \x16\x04\n\n\n\n\x03\x07\x01\x01\x12\x03\x16\x0b\x1c\n\n\n\x03\x07\x01\
    \x03\x12\x03\x16\x1f$\n\x96\x02\n\x02\x07\x02\x12\x03\x1c\x04\x1a\x1a\
    \x8a\x02\x20scalar\x20is\x20used\x20to\x20indicate\x20that\x20this\x20fi\
    eld\x20follows\x20the\x20formatting\x20defined\n\x20by\x20the\x20named\
    \x20scalar\x20which\x20should\x20be\x20declared\x20with\x20declare_scala\
    r.\x20Code\n\x20generators\x20may\x20choose\x20to\x20use\x20this\x20info\
    rmation\x20to\x20map\x20this\x20field\x20to\x20a\n\x20language-specific\
    \x20type\x20representing\x20the\x20scalar.\n\n\n\n\x03\x07\x02\x02\x12\
    \x03\x11\x07#\n\n\n\x03\x07\x02\x05\x12\x03\x1c\x04\n\n\n\n\x03\x07\x02\
    \x01\x12\x03\x1c\x0b\x11\n\n\n\x03\x07\x02\x03\x12\x03\x1c\x14\x19\n\t\n\
    \x01\x07\x12\x04\x1f\00\x01\n\x91\x03\n\x02\x07\x03\x12\x03'\x04<\x1a\
    \x85\x03\x20declare_interface\x20declares\x20an\x20interface\x20type\x20\
    to\x20be\x20used\x20with\n\x20accepts_interface\x20and\x20implements_int\
    erface.\x20Interface\x20names\x20are\n\x20expected\x20to\x20follow\x20th\
    e\x20following\x20convention\x20such\x20that\x20their\x20declaration\n\
    \x20can\x20be\x20discovered\x20by\x20tools:\x20for\x20a\x20given\x20inte\
    rface\x20type\x20a.b.C,\x20it\x20is\n\x20expected\x20that\x20the\x20decl\
    aration\x20will\x20be\x20found\x20in\x20a\x20protobuf\x20file\x20named\n\
    \x20a/b/interfaces.proto\x20in\x20the\x20file\x20descriptor\x20set.\n\n\
    \n\n\x03\x07\x03\x02\x12\x03\x1f\x07\"\n\n\n\x03\x07\x03\x04\x12\x03'\
    \x04\x0c\n\n\n\x03\x07\x03\x06\x12\x03'\r\x20\n\n\n\x03\x07\x03\x01\x12\
    \x03'!2\n\n\n\x03\x07\x03\x03\x12\x03'5;\n\xee\x02\n\x02\x07\x04\x12\x03\
    /\x046\x1a\xe2\x02\x20declare_scalar\x20declares\x20a\x20scalar\x20type\
    \x20to\x20be\x20used\x20with\n\x20the\x20scalar\x20field\x20option.\x20S\
    calar\x20names\x20are\n\x20expected\x20to\x20follow\x20the\x20following\
    \x20convention\x20such\x20that\x20their\x20declaration\n\x20can\x20be\
    \x20discovered\x20by\x20tools:\x20for\x20a\x20given\x20scalar\x20type\
    \x20a.b.C,\x20it\x20is\n\x20expected\x20that\x20the\x20declaration\x20wi\
    ll\x20be\x20found\x20in\x20a\x20protobuf\x20file\x20named\n\x20a/b/scala\
    rs.proto\x20in\x20the\x20file\x20descriptor\x20set.\n\n\n\n\x03\x07\x04\
    \x02\x12\x03\x1f\x07\"\n\n\n\x03\x07\x04\x04\x12\x03/\x04\x0c\n\n\n\x03\
    \x07\x04\x06\x12\x03/\r\x1d\n\n\n\x03\x07\x04\x01\x12\x03/\x1e,\n\n\n\
    \x03\x07\x04\x03\x12\x03//5\n\x9d\x01\n\x02\x04\0\x12\x044\0?\x01\x1a\
    \x90\x01\x20InterfaceDescriptor\x20describes\x20an\x20interface\x20type\
    \x20to\x20be\x20used\x20with\n\x20accepts_interface\x20and\x20implements\
    _interface\x20and\x20declared\x20by\x20declare_interface.\n\n\n\n\x03\
    \x04\0\x01\x12\x034\x08\x1b\n\x83\x02\n\x04\x04\0\x02\0\x12\x03:\x04\x14\
    \x1a\xf5\x01\x20name\x20is\x20the\x20name\x20of\x20the\x20interface.\x20\
    It\x20should\x20be\x20a\x20short-name\x20(without\n\x20a\x20period)\x20s\
    uch\x20that\x20the\x20fully\x20qualified\x20name\x20of\x20the\x20interfa\
    ce\x20will\x20be\n\x20package.name,\x20ex.\x20for\x20the\x20package\x20a\
    .b\x20and\x20interface\x20named\x20C,\x20the\n\x20fully-qualified\x20nam\
    e\x20will\x20be\x20a.b.C.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03:\x04\n\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03:\x0b\x0f\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03:\x12\x13\n]\n\x04\x04\0\x02\x01\x12\x03>\x04\x1b\x1aP\x20descri\
    ption\x20is\x20a\x20human-readable\x20description\x20of\x20the\x20interf\
    ace\x20and\x20its\n\x20purpose.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03>\
    \x04\n\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03>\x0b\x16\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03>\x19\x1a\n\xb2\x03\n\x02\x04\x01\x12\x04H\0Z\x01\
    \x1a\xa5\x03\x20ScalarDescriptor\x20describes\x20an\x20scalar\x20type\
    \x20to\x20be\x20used\x20with\n\x20the\x20scalar\x20field\x20option\x20an\
    d\x20declared\x20by\x20declare_scalar.\n\x20Scalars\x20extend\x20simple\
    \x20protobuf\x20built-in\x20types\x20with\x20additional\n\x20syntax\x20a\
    nd\x20semantics,\x20for\x20instance\x20to\x20represent\x20big\x20integer\
    s.\n\x20Scalars\x20should\x20ideally\x20define\x20an\x20encoding\x20such\
    \x20that\x20there\x20is\x20only\x20one\n\x20valid\x20syntactical\x20repr\
    esentation\x20for\x20a\x20given\x20semantic\x20meaning,\n\x20i.e.\x20the\
    \x20encoding\x20should\x20be\x20deterministic.\n\n\n\n\x03\x04\x01\x01\
    \x12\x03H\x08\x18\n\xfa\x01\n\x04\x04\x01\x02\0\x12\x03N\x04\x14\x1a\xec\
    \x01\x20name\x20is\x20the\x20name\x20of\x20the\x20scalar.\x20It\x20shoul\
    d\x20be\x20a\x20short-name\x20(without\n\x20a\x20period)\x20such\x20that\
    \x20the\x20fully\x20qualified\x20name\x20of\x20the\x20scalar\x20will\x20\
    be\n\x20package.name,\x20ex.\x20for\x20the\x20package\x20a.b\x20and\x20s\
    calar\x20named\x20C,\x20the\n\x20fully-qualified\x20name\x20will\x20be\
    \x20a.b.C.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03N\x04\n\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03N\x0b\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03N\x12\x13\n\xc8\x01\n\x04\x04\x01\x02\x01\x12\x03S\x04\x1b\x1a\xba\
    \x01\x20description\x20is\x20a\x20human-readable\x20description\x20of\
    \x20the\x20scalar\x20and\x20its\n\x20encoding\x20format.\x20For\x20insta\
    nce\x20a\x20big\x20integer\x20or\x20decimal\x20scalar\x20should\n\x20spe\
    cify\x20precisely\x20the\x20expected\x20encoding\x20format.\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x05\x12\x03S\x04\n\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03S\x0b\x16\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03S\x19\x1a\n\x81\
    \x02\n\x04\x04\x01\x02\x02\x12\x03Y\x04'\x1a\xf3\x01\x20field_type\x20is\
    \x20the\x20type\x20of\x20field\x20with\x20which\x20this\x20scalar\x20can\
    \x20be\x20used.\n\x20Scalars\x20can\x20be\x20used\x20with\x20one\x20and\
    \x20only\x20one\x20type\x20of\x20field\x20so\x20that\n\x20encoding\x20st\
    andards\x20and\x20simple\x20and\x20clear.\x20Currently\x20only\x20string\
    \x20and\n\x20bytes\x20fields\x20are\x20supported\x20for\x20scalars.\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x04\x12\x03Y\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x02\x06\x12\x03Y\r\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03Y\x18\"\n\
    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x03Y%&\n\n\n\x02\x05\0\x12\x04\\\0`\
    \x01\n\n\n\x03\x05\0\x01\x12\x03\\\x05\x0f\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03]\x04\x20\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03]\x04\x1b\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03]\x1e\x1f\n\x0b\n\x04\x05\0\x02\x01\x12\x03^\x04\
    \x1b\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03^\x04\x16\n\x0c\n\x05\x05\0\
    \x02\x01\x02\x12\x03^\x19\x1a\n\x0b\n\x04\x05\0\x02\x02\x12\x03_\x04\x1a\
    \n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03_\x04\x15\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03_\x18\x19b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(InterfaceDescriptor::generated_message_descriptor_data());
            messages.push(ScalarDescriptor::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ScalarType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
