// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `neutron/dex/tx.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.DepositOptions)
pub struct DepositOptions {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.DepositOptions.disable_autoswap)
    pub disable_autoswap: bool,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.DepositOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DepositOptions {
    fn default() -> &'a DepositOptions {
        <DepositOptions as ::protobuf::Message>::default_instance()
    }
}

impl DepositOptions {
    pub fn new() -> DepositOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_autoswap",
            |m: &DepositOptions| { &m.disable_autoswap },
            |m: &mut DepositOptions| { &mut m.disable_autoswap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DepositOptions>(
            "DepositOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DepositOptions {
    const NAME: &'static str = "DepositOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.disable_autoswap = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.disable_autoswap != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.disable_autoswap != false {
            os.write_bool(1, self.disable_autoswap)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DepositOptions {
        DepositOptions::new()
    }

    fn clear(&mut self) {
        self.disable_autoswap = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DepositOptions {
        static instance: DepositOptions = DepositOptions {
            disable_autoswap: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DepositOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DepositOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DepositOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DepositOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgDeposit)
pub struct MsgDeposit {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.receiver)
    pub receiver: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.token_a)
    pub token_a: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.token_b)
    pub token_b: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.amounts_a)
    pub amounts_a: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.amounts_b)
    pub amounts_b: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.tick_indexes_a_to_b)
    pub tick_indexes_a_to_b: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.fees)
    pub fees: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:neutron.dex.MsgDeposit.options)
    pub options: ::std::vec::Vec<DepositOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgDeposit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgDeposit {
    fn default() -> &'a MsgDeposit {
        <MsgDeposit as ::protobuf::Message>::default_instance()
    }
}

impl MsgDeposit {
    pub fn new() -> MsgDeposit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &MsgDeposit| { &m.creator },
            |m: &mut MsgDeposit| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receiver",
            |m: &MsgDeposit| { &m.receiver },
            |m: &mut MsgDeposit| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_a",
            |m: &MsgDeposit| { &m.token_a },
            |m: &mut MsgDeposit| { &mut m.token_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_b",
            |m: &MsgDeposit| { &m.token_b },
            |m: &mut MsgDeposit| { &mut m.token_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "amounts_a",
            |m: &MsgDeposit| { &m.amounts_a },
            |m: &mut MsgDeposit| { &mut m.amounts_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "amounts_b",
            |m: &MsgDeposit| { &m.amounts_b },
            |m: &mut MsgDeposit| { &mut m.amounts_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tick_indexes_a_to_b",
            |m: &MsgDeposit| { &m.tick_indexes_a_to_b },
            |m: &mut MsgDeposit| { &mut m.tick_indexes_a_to_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fees",
            |m: &MsgDeposit| { &m.fees },
            |m: &mut MsgDeposit| { &mut m.fees },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &MsgDeposit| { &m.options },
            |m: &mut MsgDeposit| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgDeposit>(
            "MsgDeposit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgDeposit {
    const NAME: &'static str = "MsgDeposit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creator = is.read_string()?;
                },
                18 => {
                    self.receiver = is.read_string()?;
                },
                26 => {
                    self.token_a = is.read_string()?;
                },
                34 => {
                    self.token_b = is.read_string()?;
                },
                42 => {
                    self.amounts_a.push(is.read_string()?);
                },
                50 => {
                    self.amounts_b.push(is.read_string()?);
                },
                58 => {
                    is.read_repeated_packed_int64_into(&mut self.tick_indexes_a_to_b)?;
                },
                56 => {
                    self.tick_indexes_a_to_b.push(is.read_int64()?);
                },
                66 => {
                    is.read_repeated_packed_uint64_into(&mut self.fees)?;
                },
                64 => {
                    self.fees.push(is.read_uint64()?);
                },
                74 => {
                    self.options.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.creator);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if !self.token_a.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token_a);
        }
        if !self.token_b.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.token_b);
        }
        for value in &self.amounts_a {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.amounts_b {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.tick_indexes_a_to_b {
            my_size += ::protobuf::rt::int64_size(7, *value);
        };
        for value in &self.fees {
            my_size += ::protobuf::rt::uint64_size(8, *value);
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.creator.is_empty() {
            os.write_string(1, &self.creator)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if !self.token_a.is_empty() {
            os.write_string(3, &self.token_a)?;
        }
        if !self.token_b.is_empty() {
            os.write_string(4, &self.token_b)?;
        }
        for v in &self.amounts_a {
            os.write_string(5, &v)?;
        };
        for v in &self.amounts_b {
            os.write_string(6, &v)?;
        };
        for v in &self.tick_indexes_a_to_b {
            os.write_int64(7, *v)?;
        };
        for v in &self.fees {
            os.write_uint64(8, *v)?;
        };
        for v in &self.options {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgDeposit {
        MsgDeposit::new()
    }

    fn clear(&mut self) {
        self.creator.clear();
        self.receiver.clear();
        self.token_a.clear();
        self.token_b.clear();
        self.amounts_a.clear();
        self.amounts_b.clear();
        self.tick_indexes_a_to_b.clear();
        self.fees.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgDeposit {
        static instance: MsgDeposit = MsgDeposit {
            creator: ::std::string::String::new(),
            receiver: ::std::string::String::new(),
            token_a: ::std::string::String::new(),
            token_b: ::std::string::String::new(),
            amounts_a: ::std::vec::Vec::new(),
            amounts_b: ::std::vec::Vec::new(),
            tick_indexes_a_to_b: ::std::vec::Vec::new(),
            fees: ::std::vec::Vec::new(),
            options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgDeposit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgDeposit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgDeposit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgDeposit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgDepositResponse)
pub struct MsgDepositResponse {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgDepositResponse.reserve0_deposited)
    pub reserve0_deposited: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:neutron.dex.MsgDepositResponse.reserve1_deposited)
    pub reserve1_deposited: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgDepositResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgDepositResponse {
    fn default() -> &'a MsgDepositResponse {
        <MsgDepositResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgDepositResponse {
    pub fn new() -> MsgDepositResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserve0_deposited",
            |m: &MsgDepositResponse| { &m.reserve0_deposited },
            |m: &mut MsgDepositResponse| { &mut m.reserve0_deposited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserve1_deposited",
            |m: &MsgDepositResponse| { &m.reserve1_deposited },
            |m: &mut MsgDepositResponse| { &mut m.reserve1_deposited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgDepositResponse>(
            "MsgDepositResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgDepositResponse {
    const NAME: &'static str = "MsgDepositResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reserve0_deposited.push(is.read_string()?);
                },
                18 => {
                    self.reserve1_deposited.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reserve0_deposited {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.reserve1_deposited {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.reserve0_deposited {
            os.write_string(1, &v)?;
        };
        for v in &self.reserve1_deposited {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgDepositResponse {
        MsgDepositResponse::new()
    }

    fn clear(&mut self) {
        self.reserve0_deposited.clear();
        self.reserve1_deposited.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgDepositResponse {
        static instance: MsgDepositResponse = MsgDepositResponse {
            reserve0_deposited: ::std::vec::Vec::new(),
            reserve1_deposited: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgDepositResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgDepositResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgDepositResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgDepositResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgWithdrawal)
pub struct MsgWithdrawal {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.receiver)
    pub receiver: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.token_a)
    pub token_a: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.token_b)
    pub token_b: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.shares_to_remove)
    pub shares_to_remove: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.tick_indexes_a_to_b)
    pub tick_indexes_a_to_b: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawal.fees)
    pub fees: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgWithdrawal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgWithdrawal {
    fn default() -> &'a MsgWithdrawal {
        <MsgWithdrawal as ::protobuf::Message>::default_instance()
    }
}

impl MsgWithdrawal {
    pub fn new() -> MsgWithdrawal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &MsgWithdrawal| { &m.creator },
            |m: &mut MsgWithdrawal| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receiver",
            |m: &MsgWithdrawal| { &m.receiver },
            |m: &mut MsgWithdrawal| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_a",
            |m: &MsgWithdrawal| { &m.token_a },
            |m: &mut MsgWithdrawal| { &mut m.token_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_b",
            |m: &MsgWithdrawal| { &m.token_b },
            |m: &mut MsgWithdrawal| { &mut m.token_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shares_to_remove",
            |m: &MsgWithdrawal| { &m.shares_to_remove },
            |m: &mut MsgWithdrawal| { &mut m.shares_to_remove },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tick_indexes_a_to_b",
            |m: &MsgWithdrawal| { &m.tick_indexes_a_to_b },
            |m: &mut MsgWithdrawal| { &mut m.tick_indexes_a_to_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fees",
            |m: &MsgWithdrawal| { &m.fees },
            |m: &mut MsgWithdrawal| { &mut m.fees },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgWithdrawal>(
            "MsgWithdrawal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgWithdrawal {
    const NAME: &'static str = "MsgWithdrawal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creator = is.read_string()?;
                },
                18 => {
                    self.receiver = is.read_string()?;
                },
                26 => {
                    self.token_a = is.read_string()?;
                },
                34 => {
                    self.token_b = is.read_string()?;
                },
                42 => {
                    self.shares_to_remove.push(is.read_string()?);
                },
                50 => {
                    is.read_repeated_packed_int64_into(&mut self.tick_indexes_a_to_b)?;
                },
                48 => {
                    self.tick_indexes_a_to_b.push(is.read_int64()?);
                },
                58 => {
                    is.read_repeated_packed_uint64_into(&mut self.fees)?;
                },
                56 => {
                    self.fees.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.creator);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if !self.token_a.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token_a);
        }
        if !self.token_b.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.token_b);
        }
        for value in &self.shares_to_remove {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.tick_indexes_a_to_b {
            my_size += ::protobuf::rt::int64_size(6, *value);
        };
        for value in &self.fees {
            my_size += ::protobuf::rt::uint64_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.creator.is_empty() {
            os.write_string(1, &self.creator)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if !self.token_a.is_empty() {
            os.write_string(3, &self.token_a)?;
        }
        if !self.token_b.is_empty() {
            os.write_string(4, &self.token_b)?;
        }
        for v in &self.shares_to_remove {
            os.write_string(5, &v)?;
        };
        for v in &self.tick_indexes_a_to_b {
            os.write_int64(6, *v)?;
        };
        for v in &self.fees {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgWithdrawal {
        MsgWithdrawal::new()
    }

    fn clear(&mut self) {
        self.creator.clear();
        self.receiver.clear();
        self.token_a.clear();
        self.token_b.clear();
        self.shares_to_remove.clear();
        self.tick_indexes_a_to_b.clear();
        self.fees.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgWithdrawal {
        static instance: MsgWithdrawal = MsgWithdrawal {
            creator: ::std::string::String::new(),
            receiver: ::std::string::String::new(),
            token_a: ::std::string::String::new(),
            token_b: ::std::string::String::new(),
            shares_to_remove: ::std::vec::Vec::new(),
            tick_indexes_a_to_b: ::std::vec::Vec::new(),
            fees: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgWithdrawal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgWithdrawal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgWithdrawal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgWithdrawal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgWithdrawalResponse)
pub struct MsgWithdrawalResponse {
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgWithdrawalResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgWithdrawalResponse {
    fn default() -> &'a MsgWithdrawalResponse {
        <MsgWithdrawalResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgWithdrawalResponse {
    pub fn new() -> MsgWithdrawalResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgWithdrawalResponse>(
            "MsgWithdrawalResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgWithdrawalResponse {
    const NAME: &'static str = "MsgWithdrawalResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgWithdrawalResponse {
        MsgWithdrawalResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgWithdrawalResponse {
        static instance: MsgWithdrawalResponse = MsgWithdrawalResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgWithdrawalResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgWithdrawalResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgWithdrawalResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgWithdrawalResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgPlaceLimitOrder)
pub struct MsgPlaceLimitOrder {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.receiver)
    pub receiver: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.token_in)
    pub token_in: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.token_out)
    pub token_out: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.tick_index_in_to_out)
    pub tick_index_in_to_out: i64,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.amount_in)
    pub amount_in: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.order_type)
    pub order_type: ::protobuf::EnumOrUnknown<LimitOrderType>,
    ///  expirationTime is only valid iff orderType == GOOD_TIL_TIME.
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.expiration_time)
    pub expiration_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrder.max_amount_out)
    pub max_amount_out: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgPlaceLimitOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgPlaceLimitOrder {
    fn default() -> &'a MsgPlaceLimitOrder {
        <MsgPlaceLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgPlaceLimitOrder {
    pub fn new() -> MsgPlaceLimitOrder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &MsgPlaceLimitOrder| { &m.creator },
            |m: &mut MsgPlaceLimitOrder| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receiver",
            |m: &MsgPlaceLimitOrder| { &m.receiver },
            |m: &mut MsgPlaceLimitOrder| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_in",
            |m: &MsgPlaceLimitOrder| { &m.token_in },
            |m: &mut MsgPlaceLimitOrder| { &mut m.token_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_out",
            |m: &MsgPlaceLimitOrder| { &m.token_out },
            |m: &mut MsgPlaceLimitOrder| { &mut m.token_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tick_index_in_to_out",
            |m: &MsgPlaceLimitOrder| { &m.tick_index_in_to_out },
            |m: &mut MsgPlaceLimitOrder| { &mut m.tick_index_in_to_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount_in",
            |m: &MsgPlaceLimitOrder| { &m.amount_in },
            |m: &mut MsgPlaceLimitOrder| { &mut m.amount_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_type",
            |m: &MsgPlaceLimitOrder| { &m.order_type },
            |m: &mut MsgPlaceLimitOrder| { &mut m.order_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "expiration_time",
            |m: &MsgPlaceLimitOrder| { &m.expiration_time },
            |m: &mut MsgPlaceLimitOrder| { &mut m.expiration_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_amount_out",
            |m: &MsgPlaceLimitOrder| { &m.max_amount_out },
            |m: &mut MsgPlaceLimitOrder| { &mut m.max_amount_out },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgPlaceLimitOrder>(
            "MsgPlaceLimitOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgPlaceLimitOrder {
    const NAME: &'static str = "MsgPlaceLimitOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creator = is.read_string()?;
                },
                18 => {
                    self.receiver = is.read_string()?;
                },
                26 => {
                    self.token_in = is.read_string()?;
                },
                34 => {
                    self.token_out = is.read_string()?;
                },
                40 => {
                    self.tick_index_in_to_out = is.read_int64()?;
                },
                58 => {
                    self.amount_in = is.read_string()?;
                },
                64 => {
                    self.order_type = is.read_enum_or_unknown()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expiration_time)?;
                },
                82 => {
                    self.max_amount_out = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.creator);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if !self.token_in.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token_in);
        }
        if !self.token_out.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.token_out);
        }
        if self.tick_index_in_to_out != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.tick_index_in_to_out);
        }
        if !self.amount_in.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.amount_in);
        }
        if self.order_type != ::protobuf::EnumOrUnknown::new(LimitOrderType::GOOD_TIL_CANCELLED) {
            my_size += ::protobuf::rt::int32_size(8, self.order_type.value());
        }
        if let Some(v) = self.expiration_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.max_amount_out.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.max_amount_out);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.creator.is_empty() {
            os.write_string(1, &self.creator)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if !self.token_in.is_empty() {
            os.write_string(3, &self.token_in)?;
        }
        if !self.token_out.is_empty() {
            os.write_string(4, &self.token_out)?;
        }
        if self.tick_index_in_to_out != 0 {
            os.write_int64(5, self.tick_index_in_to_out)?;
        }
        if !self.amount_in.is_empty() {
            os.write_string(7, &self.amount_in)?;
        }
        if self.order_type != ::protobuf::EnumOrUnknown::new(LimitOrderType::GOOD_TIL_CANCELLED) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.order_type))?;
        }
        if let Some(v) = self.expiration_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.max_amount_out.is_empty() {
            os.write_string(10, &self.max_amount_out)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgPlaceLimitOrder {
        MsgPlaceLimitOrder::new()
    }

    fn clear(&mut self) {
        self.creator.clear();
        self.receiver.clear();
        self.token_in.clear();
        self.token_out.clear();
        self.tick_index_in_to_out = 0;
        self.amount_in.clear();
        self.order_type = ::protobuf::EnumOrUnknown::new(LimitOrderType::GOOD_TIL_CANCELLED);
        self.expiration_time.clear();
        self.max_amount_out.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgPlaceLimitOrder {
        static instance: MsgPlaceLimitOrder = MsgPlaceLimitOrder {
            creator: ::std::string::String::new(),
            receiver: ::std::string::String::new(),
            token_in: ::std::string::String::new(),
            token_out: ::std::string::String::new(),
            tick_index_in_to_out: 0,
            amount_in: ::std::string::String::new(),
            order_type: ::protobuf::EnumOrUnknown::from_i32(0),
            expiration_time: ::protobuf::MessageField::none(),
            max_amount_out: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgPlaceLimitOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgPlaceLimitOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgPlaceLimitOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgPlaceLimitOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgPlaceLimitOrderResponse)
pub struct MsgPlaceLimitOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrderResponse.trancheKey)
    pub trancheKey: ::std::string::String,
    ///  Total amount of coin used for the limit order
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrderResponse.coin_in)
    pub coin_in: ::protobuf::MessageField<super::coin::Coin>,
    ///  Total amount of coin received from the taker portion of the limit order
    ///  This is the amount of coin immediately available in the users account after executing the
    ///  limit order. It does not include any future proceeds from the maker portion which will have withdrawn in the future
    // @@protoc_insertion_point(field:neutron.dex.MsgPlaceLimitOrderResponse.taker_coin_out)
    pub taker_coin_out: ::protobuf::MessageField<super::coin::Coin>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgPlaceLimitOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgPlaceLimitOrderResponse {
    fn default() -> &'a MsgPlaceLimitOrderResponse {
        <MsgPlaceLimitOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgPlaceLimitOrderResponse {
    pub fn new() -> MsgPlaceLimitOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trancheKey",
            |m: &MsgPlaceLimitOrderResponse| { &m.trancheKey },
            |m: &mut MsgPlaceLimitOrderResponse| { &mut m.trancheKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "coin_in",
            |m: &MsgPlaceLimitOrderResponse| { &m.coin_in },
            |m: &mut MsgPlaceLimitOrderResponse| { &mut m.coin_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "taker_coin_out",
            |m: &MsgPlaceLimitOrderResponse| { &m.taker_coin_out },
            |m: &mut MsgPlaceLimitOrderResponse| { &mut m.taker_coin_out },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgPlaceLimitOrderResponse>(
            "MsgPlaceLimitOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgPlaceLimitOrderResponse {
    const NAME: &'static str = "MsgPlaceLimitOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trancheKey = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coin_in)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.taker_coin_out)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.trancheKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trancheKey);
        }
        if let Some(v) = self.coin_in.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.taker_coin_out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.trancheKey.is_empty() {
            os.write_string(1, &self.trancheKey)?;
        }
        if let Some(v) = self.coin_in.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.taker_coin_out.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgPlaceLimitOrderResponse {
        MsgPlaceLimitOrderResponse::new()
    }

    fn clear(&mut self) {
        self.trancheKey.clear();
        self.coin_in.clear();
        self.taker_coin_out.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgPlaceLimitOrderResponse {
        static instance: MsgPlaceLimitOrderResponse = MsgPlaceLimitOrderResponse {
            trancheKey: ::std::string::String::new(),
            coin_in: ::protobuf::MessageField::none(),
            taker_coin_out: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgPlaceLimitOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgPlaceLimitOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgPlaceLimitOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgPlaceLimitOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgWithdrawFilledLimitOrder)
pub struct MsgWithdrawFilledLimitOrder {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawFilledLimitOrder.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgWithdrawFilledLimitOrder.tranche_key)
    pub tranche_key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgWithdrawFilledLimitOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgWithdrawFilledLimitOrder {
    fn default() -> &'a MsgWithdrawFilledLimitOrder {
        <MsgWithdrawFilledLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgWithdrawFilledLimitOrder {
    pub fn new() -> MsgWithdrawFilledLimitOrder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &MsgWithdrawFilledLimitOrder| { &m.creator },
            |m: &mut MsgWithdrawFilledLimitOrder| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tranche_key",
            |m: &MsgWithdrawFilledLimitOrder| { &m.tranche_key },
            |m: &mut MsgWithdrawFilledLimitOrder| { &mut m.tranche_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgWithdrawFilledLimitOrder>(
            "MsgWithdrawFilledLimitOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgWithdrawFilledLimitOrder {
    const NAME: &'static str = "MsgWithdrawFilledLimitOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creator = is.read_string()?;
                },
                18 => {
                    self.tranche_key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.creator);
        }
        if !self.tranche_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tranche_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.creator.is_empty() {
            os.write_string(1, &self.creator)?;
        }
        if !self.tranche_key.is_empty() {
            os.write_string(2, &self.tranche_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgWithdrawFilledLimitOrder {
        MsgWithdrawFilledLimitOrder::new()
    }

    fn clear(&mut self) {
        self.creator.clear();
        self.tranche_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgWithdrawFilledLimitOrder {
        static instance: MsgWithdrawFilledLimitOrder = MsgWithdrawFilledLimitOrder {
            creator: ::std::string::String::new(),
            tranche_key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgWithdrawFilledLimitOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgWithdrawFilledLimitOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgWithdrawFilledLimitOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgWithdrawFilledLimitOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgWithdrawFilledLimitOrderResponse)
pub struct MsgWithdrawFilledLimitOrderResponse {
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgWithdrawFilledLimitOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgWithdrawFilledLimitOrderResponse {
    fn default() -> &'a MsgWithdrawFilledLimitOrderResponse {
        <MsgWithdrawFilledLimitOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgWithdrawFilledLimitOrderResponse {
    pub fn new() -> MsgWithdrawFilledLimitOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgWithdrawFilledLimitOrderResponse>(
            "MsgWithdrawFilledLimitOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgWithdrawFilledLimitOrderResponse {
    const NAME: &'static str = "MsgWithdrawFilledLimitOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgWithdrawFilledLimitOrderResponse {
        MsgWithdrawFilledLimitOrderResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgWithdrawFilledLimitOrderResponse {
        static instance: MsgWithdrawFilledLimitOrderResponse = MsgWithdrawFilledLimitOrderResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgWithdrawFilledLimitOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgWithdrawFilledLimitOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgWithdrawFilledLimitOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgWithdrawFilledLimitOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgCancelLimitOrder)
pub struct MsgCancelLimitOrder {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgCancelLimitOrder.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgCancelLimitOrder.tranche_key)
    pub tranche_key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgCancelLimitOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgCancelLimitOrder {
    fn default() -> &'a MsgCancelLimitOrder {
        <MsgCancelLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelLimitOrder {
    pub fn new() -> MsgCancelLimitOrder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &MsgCancelLimitOrder| { &m.creator },
            |m: &mut MsgCancelLimitOrder| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tranche_key",
            |m: &MsgCancelLimitOrder| { &m.tranche_key },
            |m: &mut MsgCancelLimitOrder| { &mut m.tranche_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgCancelLimitOrder>(
            "MsgCancelLimitOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgCancelLimitOrder {
    const NAME: &'static str = "MsgCancelLimitOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creator = is.read_string()?;
                },
                18 => {
                    self.tranche_key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.creator);
        }
        if !self.tranche_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tranche_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.creator.is_empty() {
            os.write_string(1, &self.creator)?;
        }
        if !self.tranche_key.is_empty() {
            os.write_string(2, &self.tranche_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgCancelLimitOrder {
        MsgCancelLimitOrder::new()
    }

    fn clear(&mut self) {
        self.creator.clear();
        self.tranche_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgCancelLimitOrder {
        static instance: MsgCancelLimitOrder = MsgCancelLimitOrder {
            creator: ::std::string::String::new(),
            tranche_key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgCancelLimitOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgCancelLimitOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgCancelLimitOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelLimitOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgCancelLimitOrderResponse)
pub struct MsgCancelLimitOrderResponse {
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgCancelLimitOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgCancelLimitOrderResponse {
    fn default() -> &'a MsgCancelLimitOrderResponse {
        <MsgCancelLimitOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelLimitOrderResponse {
    pub fn new() -> MsgCancelLimitOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgCancelLimitOrderResponse>(
            "MsgCancelLimitOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgCancelLimitOrderResponse {
    const NAME: &'static str = "MsgCancelLimitOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgCancelLimitOrderResponse {
        MsgCancelLimitOrderResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgCancelLimitOrderResponse {
        static instance: MsgCancelLimitOrderResponse = MsgCancelLimitOrderResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgCancelLimitOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgCancelLimitOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgCancelLimitOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelLimitOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MultiHopRoute)
pub struct MultiHopRoute {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MultiHopRoute.hops)
    pub hops: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MultiHopRoute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiHopRoute {
    fn default() -> &'a MultiHopRoute {
        <MultiHopRoute as ::protobuf::Message>::default_instance()
    }
}

impl MultiHopRoute {
    pub fn new() -> MultiHopRoute {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hops",
            |m: &MultiHopRoute| { &m.hops },
            |m: &mut MultiHopRoute| { &mut m.hops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiHopRoute>(
            "MultiHopRoute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiHopRoute {
    const NAME: &'static str = "MultiHopRoute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hops.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hops {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hops {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiHopRoute {
        MultiHopRoute::new()
    }

    fn clear(&mut self) {
        self.hops.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiHopRoute {
        static instance: MultiHopRoute = MultiHopRoute {
            hops: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiHopRoute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiHopRoute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiHopRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiHopRoute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgMultiHopSwap)
pub struct MsgMultiHopSwap {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwap.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwap.receiver)
    pub receiver: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwap.routes)
    pub routes: ::std::vec::Vec<MultiHopRoute>,
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwap.amount_in)
    pub amount_in: ::std::string::String,
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwap.exit_limit_price)
    pub exit_limit_price: ::std::string::String,
    ///  If pickBestRoute == true then all routes are run and the route with the best price is chosen
    ///  otherwise, the first succesful route is used.
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwap.pick_best_route)
    pub pick_best_route: bool,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgMultiHopSwap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgMultiHopSwap {
    fn default() -> &'a MsgMultiHopSwap {
        <MsgMultiHopSwap as ::protobuf::Message>::default_instance()
    }
}

impl MsgMultiHopSwap {
    pub fn new() -> MsgMultiHopSwap {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &MsgMultiHopSwap| { &m.creator },
            |m: &mut MsgMultiHopSwap| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receiver",
            |m: &MsgMultiHopSwap| { &m.receiver },
            |m: &mut MsgMultiHopSwap| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "routes",
            |m: &MsgMultiHopSwap| { &m.routes },
            |m: &mut MsgMultiHopSwap| { &mut m.routes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount_in",
            |m: &MsgMultiHopSwap| { &m.amount_in },
            |m: &mut MsgMultiHopSwap| { &mut m.amount_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exit_limit_price",
            |m: &MsgMultiHopSwap| { &m.exit_limit_price },
            |m: &mut MsgMultiHopSwap| { &mut m.exit_limit_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pick_best_route",
            |m: &MsgMultiHopSwap| { &m.pick_best_route },
            |m: &mut MsgMultiHopSwap| { &mut m.pick_best_route },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgMultiHopSwap>(
            "MsgMultiHopSwap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgMultiHopSwap {
    const NAME: &'static str = "MsgMultiHopSwap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creator = is.read_string()?;
                },
                18 => {
                    self.receiver = is.read_string()?;
                },
                26 => {
                    self.routes.push(is.read_message()?);
                },
                34 => {
                    self.amount_in = is.read_string()?;
                },
                42 => {
                    self.exit_limit_price = is.read_string()?;
                },
                48 => {
                    self.pick_best_route = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.creator);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.amount_in.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.amount_in);
        }
        if !self.exit_limit_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.exit_limit_price);
        }
        if self.pick_best_route != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.creator.is_empty() {
            os.write_string(1, &self.creator)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        for v in &self.routes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.amount_in.is_empty() {
            os.write_string(4, &self.amount_in)?;
        }
        if !self.exit_limit_price.is_empty() {
            os.write_string(5, &self.exit_limit_price)?;
        }
        if self.pick_best_route != false {
            os.write_bool(6, self.pick_best_route)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgMultiHopSwap {
        MsgMultiHopSwap::new()
    }

    fn clear(&mut self) {
        self.creator.clear();
        self.receiver.clear();
        self.routes.clear();
        self.amount_in.clear();
        self.exit_limit_price.clear();
        self.pick_best_route = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgMultiHopSwap {
        static instance: MsgMultiHopSwap = MsgMultiHopSwap {
            creator: ::std::string::String::new(),
            receiver: ::std::string::String::new(),
            routes: ::std::vec::Vec::new(),
            amount_in: ::std::string::String::new(),
            exit_limit_price: ::std::string::String::new(),
            pick_best_route: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgMultiHopSwap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgMultiHopSwap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgMultiHopSwap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgMultiHopSwap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgMultiHopSwapResponse)
pub struct MsgMultiHopSwapResponse {
    // message fields
    // @@protoc_insertion_point(field:neutron.dex.MsgMultiHopSwapResponse.coin_out)
    pub coin_out: ::protobuf::MessageField<super::coin::Coin>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgMultiHopSwapResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgMultiHopSwapResponse {
    fn default() -> &'a MsgMultiHopSwapResponse {
        <MsgMultiHopSwapResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgMultiHopSwapResponse {
    pub fn new() -> MsgMultiHopSwapResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "coin_out",
            |m: &MsgMultiHopSwapResponse| { &m.coin_out },
            |m: &mut MsgMultiHopSwapResponse| { &mut m.coin_out },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgMultiHopSwapResponse>(
            "MsgMultiHopSwapResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgMultiHopSwapResponse {
    const NAME: &'static str = "MsgMultiHopSwapResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coin_out)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_out.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgMultiHopSwapResponse {
        MsgMultiHopSwapResponse::new()
    }

    fn clear(&mut self) {
        self.coin_out.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgMultiHopSwapResponse {
        static instance: MsgMultiHopSwapResponse = MsgMultiHopSwapResponse {
            coin_out: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgMultiHopSwapResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgMultiHopSwapResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgMultiHopSwapResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgMultiHopSwapResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgUpdateParams)
pub struct MsgUpdateParams {
    // message fields
    ///  Authority is the address of the governance account.
    // @@protoc_insertion_point(field:neutron.dex.MsgUpdateParams.authority)
    pub authority: ::std::string::String,
    ///  NOTE: All parameters must be supplied.
    // @@protoc_insertion_point(field:neutron.dex.MsgUpdateParams.params)
    pub params: ::protobuf::MessageField<super::params::Params>,
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgUpdateParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgUpdateParams {
    fn default() -> &'a MsgUpdateParams {
        <MsgUpdateParams as ::protobuf::Message>::default_instance()
    }
}

impl MsgUpdateParams {
    pub fn new() -> MsgUpdateParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "authority",
            |m: &MsgUpdateParams| { &m.authority },
            |m: &mut MsgUpdateParams| { &mut m.authority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::params::Params>(
            "params",
            |m: &MsgUpdateParams| { &m.params },
            |m: &mut MsgUpdateParams| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgUpdateParams>(
            "MsgUpdateParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.authority = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.authority.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authority);
        }
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.authority.is_empty() {
            os.write_string(1, &self.authority)?;
        }
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgUpdateParams {
        MsgUpdateParams::new()
    }

    fn clear(&mut self) {
        self.authority.clear();
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgUpdateParams {
        static instance: MsgUpdateParams = MsgUpdateParams {
            authority: ::std::string::String::new(),
            params: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgUpdateParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgUpdateParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgUpdateParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgUpdateParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgUpdateParamsResponse defines the response structure for executing a
///  MsgUpdateParams message.
///
///  Since: 0.47
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:neutron.dex.MsgUpdateParamsResponse)
pub struct MsgUpdateParamsResponse {
    // special fields
    // @@protoc_insertion_point(special_field:neutron.dex.MsgUpdateParamsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgUpdateParamsResponse {
    fn default() -> &'a MsgUpdateParamsResponse {
        <MsgUpdateParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgUpdateParamsResponse {
    pub fn new() -> MsgUpdateParamsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgUpdateParamsResponse>(
            "MsgUpdateParamsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgUpdateParamsResponse {
        MsgUpdateParamsResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgUpdateParamsResponse {
        static instance: MsgUpdateParamsResponse = MsgUpdateParamsResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgUpdateParamsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgUpdateParamsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgUpdateParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgUpdateParamsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:neutron.dex.LimitOrderType)
pub enum LimitOrderType {
    // @@protoc_insertion_point(enum_value:neutron.dex.LimitOrderType.GOOD_TIL_CANCELLED)
    GOOD_TIL_CANCELLED = 0,
    // @@protoc_insertion_point(enum_value:neutron.dex.LimitOrderType.FILL_OR_KILL)
    FILL_OR_KILL = 1,
    // @@protoc_insertion_point(enum_value:neutron.dex.LimitOrderType.IMMEDIATE_OR_CANCEL)
    IMMEDIATE_OR_CANCEL = 2,
    // @@protoc_insertion_point(enum_value:neutron.dex.LimitOrderType.JUST_IN_TIME)
    JUST_IN_TIME = 3,
    // @@protoc_insertion_point(enum_value:neutron.dex.LimitOrderType.GOOD_TIL_TIME)
    GOOD_TIL_TIME = 4,
}

impl ::protobuf::Enum for LimitOrderType {
    const NAME: &'static str = "LimitOrderType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LimitOrderType> {
        match value {
            0 => ::std::option::Option::Some(LimitOrderType::GOOD_TIL_CANCELLED),
            1 => ::std::option::Option::Some(LimitOrderType::FILL_OR_KILL),
            2 => ::std::option::Option::Some(LimitOrderType::IMMEDIATE_OR_CANCEL),
            3 => ::std::option::Option::Some(LimitOrderType::JUST_IN_TIME),
            4 => ::std::option::Option::Some(LimitOrderType::GOOD_TIL_TIME),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LimitOrderType] = &[
        LimitOrderType::GOOD_TIL_CANCELLED,
        LimitOrderType::FILL_OR_KILL,
        LimitOrderType::IMMEDIATE_OR_CANCEL,
        LimitOrderType::JUST_IN_TIME,
        LimitOrderType::GOOD_TIL_TIME,
    ];
}

impl ::protobuf::EnumFull for LimitOrderType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LimitOrderType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LimitOrderType {
    fn default() -> Self {
        LimitOrderType::GOOD_TIL_CANCELLED
    }
}

impl LimitOrderType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LimitOrderType>("LimitOrderType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14neutron/dex/tx.proto\x12\x0bneutron.dex\x1a\x14gogoproto/gogo.prot\
    o\x1a\x1ecosmos/base/v1beta1/coin.proto\x1a\x1fgoogle/protobuf/timestamp\
    .proto\x1a\x11amino/amino.proto\x1a\x18neutron/dex/params.proto\x1a\x17c\
    osmos/msg/v1/msg.proto\x1a\x19cosmos_proto/cosmos.proto\";\n\x0eDepositO\
    ptions\x12)\n\x10disable_autoswap\x18\x01\x20\x01(\x08R\x0fdisableAutosw\
    ap\"\xc9\x03\n\nMsgDeposit\x12\x18\n\x07creator\x18\x01\x20\x01(\tR\x07c\
    reator\x12\x1a\n\x08receiver\x18\x02\x20\x01(\tR\x08receiver\x12\x17\n\
    \x07token_a\x18\x03\x20\x01(\tR\x06tokenA\x12\x17\n\x07token_b\x18\x04\
    \x20\x01(\tR\x06tokenB\x12l\n\tamounts_a\x18\x05\x20\x03(\tR\x08amountsA\
    BO\xf2\xde\x1f\x10yaml:\"amounts_a\"\xda\xde\x1f&github.com/cosmos/cosmo\
    s-sdk/types.Int\xc8\xde\x1f\0\xea\xde\x1f\tamounts_a\x12l\n\tamounts_b\
    \x18\x06\x20\x03(\tR\x08amountsBBO\xf2\xde\x1f\x10yaml:\"amounts_b\"\xda\
    \xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0\xea\xde\
    \x1f\tamounts_b\x12,\n\x13tick_indexes_a_to_b\x18\x07\x20\x03(\x03R\x0ft\
    ickIndexesAToB\x12\x12\n\x04fees\x18\x08\x20\x03(\x04R\x04fees\x125\n\
    \x07options\x18\t\x20\x03(\x0b2\x1b.neutron.dex.DepositOptionsR\x07optio\
    ns\"\xba\x02\n\x12MsgDepositResponse\x12\x90\x01\n\x12reserve0_deposited\
    \x18\x01\x20\x03(\tR\x11reserve0DepositedBa\xf2\xde\x1f\x19yaml:\"reserv\
    e0_deposited\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\
    \xde\x1f\0\xea\xde\x1f\x12reserve0_deposited\x12\x90\x01\n\x12reserve1_d\
    eposited\x18\x02\x20\x03(\tR\x11reserve1DepositedBa\xf2\xde\x1f\x19yaml:\
    \"reserve1_deposited\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.In\
    t\xc8\xde\x1f\0\xea\xde\x1f\x12reserve1_deposited\"\xc3\x02\n\rMsgWithdr\
    awal\x12\x18\n\x07creator\x18\x01\x20\x01(\tR\x07creator\x12\x1a\n\x08re\
    ceiver\x18\x02\x20\x01(\tR\x08receiver\x12\x17\n\x07token_a\x18\x03\x20\
    \x01(\tR\x06tokenA\x12\x17\n\x07token_b\x18\x04\x20\x01(\tR\x06tokenB\
    \x12\x87\x01\n\x10shares_to_remove\x18\x05\x20\x03(\tR\x0esharesToRemove\
    B]\xf2\xde\x1f\x17yaml:\"shares_to_remove\"\xda\xde\x1f&github.com/cosmo\
    s/cosmos-sdk/types.Int\xc8\xde\x1f\0\xea\xde\x1f\x10shares_to_remove\x12\
    ,\n\x13tick_indexes_a_to_b\x18\x06\x20\x03(\x03R\x0ftickIndexesAToB\x12\
    \x12\n\x04fees\x18\x07\x20\x03(\x04R\x04fees\"\x17\n\x15MsgWithdrawalRes\
    ponse\"\xac\x04\n\x12MsgPlaceLimitOrder\x12\x18\n\x07creator\x18\x01\x20\
    \x01(\tR\x07creator\x12\x1a\n\x08receiver\x18\x02\x20\x01(\tR\x08receive\
    r\x12\x19\n\x08token_in\x18\x03\x20\x01(\tR\x07tokenIn\x12\x1b\n\ttoken_\
    out\x18\x04\x20\x01(\tR\x08tokenOut\x12.\n\x14tick_index_in_to_out\x18\
    \x05\x20\x01(\x03R\x10tickIndexInToOut\x12l\n\tamount_in\x18\x07\x20\x01\
    (\tR\x08amountInBO\xf2\xde\x1f\x10yaml:\"amount_in\"\xda\xde\x1f&github.\
    com/cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0\xea\xde\x1f\tamount_in\x12\
    :\n\norder_type\x18\x08\x20\x01(\x0e2\x1b.neutron.dex.LimitOrderTypeR\to\
    rderType\x12M\n\x0fexpiration_time\x18\t\x20\x01(\x0b2\x1a.google.protob\
    uf.TimestampR\x0eexpirationTimeB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\x01\x12\
    \x7f\n\x0emax_amount_out\x18\n\x20\x01(\tR\x0cmaxAmountOutBY\xf2\xde\x1f\
    \x15yaml:\"max_amount_out\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/typ\
    es.Int\xc8\xde\x1f\x01\xea\xde\x1f\x0emax_amount_out\"\xdd\x02\n\x1aMsgP\
    laceLimitOrderResponse\x12\x1e\n\ntrancheKey\x18\x01\x20\x01(\tR\ntranch\
    eKey\x12\x80\x01\n\x07coin_in\x18\x02\x20\x01(\x0b2\x19.cosmos.base.v1be\
    ta1.CoinR\x06coinInBL\xf2\xde\x1f\x0eyaml:\"coin_in\"\xc8\xde\x1f\0\xda\
    \xde\x1f'github.com/cosmos/cosmos-sdk/types.Coin\xea\xde\x1f\x07coin_in\
    \x12\x9b\x01\n\x0etaker_coin_out\x18\x03\x20\x01(\x0b2\x19.cosmos.base.v\
    1beta1.CoinR\x0ctakerCoinOutBZ\xf2\xde\x1f\x15yaml:\"taker_coin_out\"\
    \xc8\xde\x1f\0\xda\xde\x1f'github.com/cosmos/cosmos-sdk/types.Coin\xea\
    \xde\x1f\x0etaker_coin_out\"X\n\x1bMsgWithdrawFilledLimitOrder\x12\x18\n\
    \x07creator\x18\x01\x20\x01(\tR\x07creator\x12\x1f\n\x0btranche_key\x18\
    \x02\x20\x01(\tR\ntrancheKey\"%\n#MsgWithdrawFilledLimitOrderResponse\"P\
    \n\x13MsgCancelLimitOrder\x12\x18\n\x07creator\x18\x01\x20\x01(\tR\x07cr\
    eator\x12\x1f\n\x0btranche_key\x18\x02\x20\x01(\tR\ntrancheKey\"\x1d\n\
    \x1bMsgCancelLimitOrderResponse\"#\n\rMultiHopRoute\x12\x12\n\x04hops\
    \x18\x01\x20\x03(\tR\x04hops\"\xa6\x03\n\x0fMsgMultiHopSwap\x12\x18\n\
    \x07creator\x18\x01\x20\x01(\tR\x07creator\x12\x1a\n\x08receiver\x18\x02\
    \x20\x01(\tR\x08receiver\x122\n\x06routes\x18\x03\x20\x03(\x0b2\x1a.neut\
    ron.dex.MultiHopRouteR\x06routes\x12l\n\tamount_in\x18\x04\x20\x01(\tR\
    \x08amountInBO\xf2\xde\x1f\x10yaml:\"amount_in\"\xda\xde\x1f&github.com/\
    cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0\xea\xde\x1f\tamount_in\x12\x92\
    \x01\n\x10exit_limit_price\x18\x05\x20\x01(\tR\x0eexitLimitPriceBh\xf2\
    \xde\x1f\x17yaml:\"exit_limit_price\"\xda\xde\x1f1github.com/neutron-org\
    /neutron/utils/math.PrecDec\xc8\xde\x1f\0\xea\xde\x1f\x10exit_limit_pric\
    e\x12&\n\x0fpick_best_route\x18\x06\x20\x01(\x08R\rpickBestRoute\"\x8c\
    \x01\n\x17MsgMultiHopSwapResponse\x12q\n\x08coin_out\x18\x01\x20\x01(\
    \x0b2\x19.cosmos.base.v1beta1.CoinR\x07coinOutB;\xc8\xde\x1f\0\xda\xde\
    \x1f'github.com/cosmos/cosmos-sdk/types.Coin\xea\xde\x1f\x08coin_out\"\
    \xa9\x01\n\x0fMsgUpdateParams\x126\n\tauthority\x18\x01\x20\x01(\tR\taut\
    horityB\x18\xd2\xb4-\x14cosmos.AddressString\x126\n\x06params\x18\x02\
    \x20\x01(\x0b2\x13.neutron.dex.ParamsR\x06paramsB\t\xc8\xde\x1f\0\xa8\
    \xe7\xb0*\x01:&\x8a\xe7\xb0*\x13dex/MsgUpdateParams\x82\xe7\xb0*\tauthor\
    ity\"\x19\n\x17MsgUpdateParamsResponse*x\n\x0eLimitOrderType\x12\x16\n\
    \x12GOOD_TIL_CANCELLED\x10\0\x12\x10\n\x0cFILL_OR_KILL\x10\x01\x12\x17\n\
    \x13IMMEDIATE_OR_CANCEL\x10\x02\x12\x10\n\x0cJUST_IN_TIME\x10\x03\x12\
    \x11\n\rGOOD_TIL_TIME\x10\x042\xf5\x04\n\x03Msg\x12C\n\x07Deposit\x12\
    \x17.neutron.dex.MsgDeposit\x1a\x1f.neutron.dex.MsgDepositResponse\x12L\
    \n\nWithdrawal\x12\x1a.neutron.dex.MsgWithdrawal\x1a\".neutron.dex.MsgWi\
    thdrawalResponse\x12[\n\x0fPlaceLimitOrder\x12\x1f.neutron.dex.MsgPlaceL\
    imitOrder\x1a'.neutron.dex.MsgPlaceLimitOrderResponse\x12v\n\x18Withdraw\
    FilledLimitOrder\x12(.neutron.dex.MsgWithdrawFilledLimitOrder\x1a0.neutr\
    on.dex.MsgWithdrawFilledLimitOrderResponse\x12^\n\x10CancelLimitOrder\
    \x12\x20.neutron.dex.MsgCancelLimitOrder\x1a(.neutron.dex.MsgCancelLimit\
    OrderResponse\x12R\n\x0cMultiHopSwap\x12\x1c.neutron.dex.MsgMultiHopSwap\
    \x1a$.neutron.dex.MsgMultiHopSwapResponse\x12R\n\x0cUpdateParams\x12\x1c\
    .neutron.dex.MsgUpdateParams\x1a$.neutron.dex.MsgUpdateParamsResponseB,Z\
    *github.com/neutron-org/neutron/x/dex/typesJ\xf7.\n\x07\x12\x05\0\0\xcd\
    \x01\"\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x14\
    \n\x08\n\x01\x08\x12\x03\x05\0A\nH\n\x02\x08\x0b\x12\x03\x05\0A2=\x20thi\
    s\x20line\x20is\x20used\x20by\x20starport\x20scaffolding\x20#\x20proto/t\
    x/import\n\n\t\n\x02\x03\0\x12\x03\x06\0\x1e\n\t\n\x02\x03\x01\x12\x03\
    \x07\0(\n\t\n\x02\x03\x02\x12\x03\x08\0)\n\t\n\x02\x03\x03\x12\x03\t\0\
    \x1b\n\t\n\x02\x03\x04\x12\x03\n\0\"\n\t\n\x02\x03\x05\x12\x03\x0b\0!\n\
    \t\n\x02\x03\x06\x12\x03\x0c\0#\n*\n\x02\x06\0\x12\x04\x0f\0\x18\x01\x1a\
    \x1e\x20Msg\x20defines\x20the\x20Msg\x20service.\n\n\n\n\x03\x06\0\x01\
    \x12\x03\x0f\x08\x0b\n\x0b\n\x04\x06\0\x02\0\x12\x03\x10\x027\n\x0c\n\
    \x05\x06\0\x02\0\x01\x12\x03\x10\x06\r\n\x0c\n\x05\x06\0\x02\0\x02\x12\
    \x03\x10\x0e\x18\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x10#5\n\x0b\n\x04\
    \x06\0\x02\x01\x12\x03\x11\x02@\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\
    \x11\x06\x10\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x11\x11\x1e\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03\x11)>\n\x0b\n\x04\x06\0\x02\x02\x12\x03\
    \x12\x02O\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x12\x06\x15\n\x0c\n\x05\
    \x06\0\x02\x02\x02\x12\x03\x12\x16(\n\x0c\n\x05\x06\0\x02\x02\x03\x12\
    \x03\x123M\n\x0b\n\x04\x06\0\x02\x03\x12\x03\x13\x02j\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03\x13\x06\x1e\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\
    \x13\x1f:\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x13Eh\n\x0b\n\x04\x06\0\
    \x02\x04\x12\x03\x14\x02R\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x14\x06\
    \x16\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\x14\x17*\n\x0c\n\x05\x06\0\
    \x02\x04\x03\x12\x03\x145P\n\x0b\n\x04\x06\0\x02\x05\x12\x03\x15\x02F\n\
    \x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x15\x06\x12\n\x0c\n\x05\x06\0\x02\
    \x05\x02\x12\x03\x15\x13\"\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03\x15-D\n\
    G\n\x04\x06\0\x02\x06\x12\x03\x16\x02F\":\x20this\x20line\x20is\x20used\
    \x20by\x20starport\x20scaffolding\x20#\x20proto/tx/rpc\n\n\x0c\n\x05\x06\
    \0\x02\x06\x01\x12\x03\x16\x06\x12\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03\
    \x16\x13\"\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x16-D\n\n\n\x02\x04\0\
    \x12\x04\x1a\0\x1c\x01\n\n\n\x03\x04\0\x01\x12\x03\x1a\x08\x16\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03\x1b\x02\x1c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \x1b\x02\x06\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1b\x07\x17\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x1b\x1a\x1b\n\n\n\x02\x04\x01\x12\x04\x1e\02\
    \x01\n\n\n\x03\x04\x01\x01\x12\x03\x1e\x08\x12\n\x0b\n\x04\x04\x01\x02\0\
    \x12\x03\x1f\x02\x15\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1f\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1f\t\x10\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03\x1f\x13\x14\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x20\x02\x16\
    \n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03\x20\t\x11\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\
    \x20\x14\x15\n\x0b\n\x04\x04\x01\x02\x02\x12\x03!\x02\x15\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03!\t\x10\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03!\x13\x14\n\x0b\n\
    \x04\x04\x01\x02\x03\x12\x03\"\x02\x15\n\x0c\n\x05\x04\x01\x02\x03\x05\
    \x12\x03\"\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\"\t\x10\n\x0c\
    \n\x05\x04\x01\x02\x03\x03\x12\x03\"\x13\x14\n\x0c\n\x04\x04\x01\x02\x04\
    \x12\x04#\x02(\x04\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03#\x02\n\n\x0c\
    \n\x05\x04\x01\x02\x04\x05\x12\x03#\x0b\x11\n\x0c\n\x05\x04\x01\x02\x04\
    \x01\x12\x03#\x12\x1b\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03#\x1e\x1f\n\
    \r\n\x05\x04\x01\x02\x04\x08\x12\x04#!(\x03\n\x0f\n\x08\x04\x01\x02\x04\
    \x08\xee\xfb\x03\x12\x03$\x063\n\x0f\n\x08\x04\x01\x02\x04\x08\xeb\xfb\
    \x03\x12\x03%\x06G\n\x0f\n\x08\x04\x01\x02\x04\x08\xe9\xfb\x03\x12\x03&\
    \x06$\n\x0f\n\x08\x04\x01\x02\x04\x08\xed\xfb\x03\x12\x03'\x06'\n\x0c\n\
    \x04\x04\x01\x02\x05\x12\x04)\x03.\x04\n\x0c\n\x05\x04\x01\x02\x05\x04\
    \x12\x03)\x03\x0b\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03)\x0c\x12\n\x0c\
    \n\x05\x04\x01\x02\x05\x01\x12\x03)\x13\x1c\n\x0c\n\x05\x04\x01\x02\x05\
    \x03\x12\x03)\x1f\x20\n\r\n\x05\x04\x01\x02\x05\x08\x12\x04)\".\x03\n\
    \x0f\n\x08\x04\x01\x02\x05\x08\xee\xfb\x03\x12\x03*\x063\n\x0f\n\x08\x04\
    \x01\x02\x05\x08\xeb\xfb\x03\x12\x03+\x06G\n\x0f\n\x08\x04\x01\x02\x05\
    \x08\xe9\xfb\x03\x12\x03,\x06$\n\x0f\n\x08\x04\x01\x02\x05\x08\xed\xfb\
    \x03\x12\x03-\x06'\n\x0b\n\x04\x04\x01\x02\x06\x12\x03/\x02)\n\x0c\n\x05\
    \x04\x01\x02\x06\x04\x12\x03/\x02\n\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\
    \x03/\x0b\x10\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03/\x11$\n\x0c\n\x05\
    \x04\x01\x02\x06\x03\x12\x03/'(\n\x0b\n\x04\x04\x01\x02\x07\x12\x030\x02\
    \x1b\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x030\x02\n\n\x0c\n\x05\x04\x01\
    \x02\x07\x05\x12\x030\x0b\x11\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x030\
    \x12\x16\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x030\x19\x1a\n\x0b\n\x04\
    \x04\x01\x02\x08\x12\x031\x02&\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x031\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x08\x06\x12\x031\x0b\x19\n\x0c\n\x05\x04\
    \x01\x02\x08\x01\x12\x031\x1a!\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x031$\
    %\n\n\n\x02\x04\x02\x12\x044\0A\x01\n\n\n\x03\x04\x02\x01\x12\x034\x08\
    \x1a\n\x0c\n\x04\x04\x02\x02\0\x12\x045\x03:\x04\n\x0c\n\x05\x04\x02\x02\
    \0\x04\x12\x035\x03\x0b\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x035\x0c\x12\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x035\x13%\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x035()\n\r\n\x05\x04\x02\x02\0\x08\x12\x045*:\x03\n\x0f\n\x08\x04\
    \x02\x02\0\x08\xee\xfb\x03\x12\x036\x06<\n\x0f\n\x08\x04\x02\x02\0\x08\
    \xeb\xfb\x03\x12\x037\x06G\n\x0f\n\x08\x04\x02\x02\0\x08\xe9\xfb\x03\x12\
    \x038\x06$\n\x0f\n\x08\x04\x02\x02\0\x08\xed\xfb\x03\x12\x039\x060\n\x0c\
    \n\x04\x04\x02\x02\x01\x12\x04;\x02@\x04\n\x0c\n\x05\x04\x02\x02\x01\x04\
    \x12\x03;\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03;\x0b\x11\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x03;\x12$\n\x0c\n\x05\x04\x02\x02\x01\x03\
    \x12\x03;'(\n\r\n\x05\x04\x02\x02\x01\x08\x12\x04;(@\x03\n\x0f\n\x08\x04\
    \x02\x02\x01\x08\xee\xfb\x03\x12\x03<\x06<\n\x0f\n\x08\x04\x02\x02\x01\
    \x08\xeb\xfb\x03\x12\x03=\x06G\n\x0f\n\x08\x04\x02\x02\x01\x08\xe9\xfb\
    \x03\x12\x03>\x06$\n\x0f\n\x08\x04\x02\x02\x01\x08\xed\xfb\x03\x12\x03?\
    \x060\n\n\n\x02\x04\x03\x12\x04C\0Q\x01\n\n\n\x03\x04\x03\x01\x12\x03C\
    \x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\x03D\x02\x15\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03D\t\x10\
    \n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03D\x13\x14\n\x0b\n\x04\x04\x03\x02\
    \x01\x12\x03E\x02\x16\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03E\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03E\t\x11\n\x0c\n\x05\x04\x03\x02\
    \x01\x03\x12\x03E\x14\x15\n\x0b\n\x04\x04\x03\x02\x02\x12\x03F\x02\x15\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03F\t\x10\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03F\x13\x14\
    \n\x0b\n\x04\x04\x03\x02\x03\x12\x03G\x02\x15\n\x0c\n\x05\x04\x03\x02\
    \x03\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03G\t\x10\
    \n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03G\x13\x14\n\x0c\n\x04\x04\x03\
    \x02\x04\x12\x04H\x02M\x04\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03H\x02\
    \n\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03H\x0b\x11\n\x0c\n\x05\x04\x03\
    \x02\x04\x01\x12\x03H\x12\"\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03H%&\n\
    \r\n\x05\x04\x03\x02\x04\x08\x12\x04H(M\x03\n\x0f\n\x08\x04\x03\x02\x04\
    \x08\xee\xfb\x03\x12\x03I\x06:\n\x0f\n\x08\x04\x03\x02\x04\x08\xeb\xfb\
    \x03\x12\x03J\x06G\n\x0f\n\x08\x04\x03\x02\x04\x08\xe9\xfb\x03\x12\x03K\
    \x06$\n\x0f\n\x08\x04\x03\x02\x04\x08\xed\xfb\x03\x12\x03L\x06.\n\x0b\n\
    \x04\x04\x03\x02\x05\x12\x03N\x02)\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\
    \x03N\x02\n\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03N\x0b\x10\n\x0c\n\x05\
    \x04\x03\x02\x05\x01\x12\x03N\x11$\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\
    \x03N'(\n\x0b\n\x04\x04\x03\x02\x06\x12\x03O\x02\x1b\n\x0c\n\x05\x04\x03\
    \x02\x06\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x03O\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03O\x12\x16\n\x0c\n\x05\x04\
    \x03\x02\x06\x03\x12\x03O\x19\x1a\n\n\n\x02\x04\x04\x12\x04S\0T\x01\n\n\
    \n\x03\x04\x04\x01\x12\x03S\x08\x1d\n\n\n\x02\x05\0\x12\x04V\0\\\x01\n\n\
    \n\x03\x05\0\x01\x12\x03V\x05\x13\n\x0b\n\x04\x05\0\x02\0\x12\x03W\x02\
    \x19\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03W\x02\x14\n\x0c\n\x05\x05\0\x02\
    \0\x02\x12\x03W\x17\x18\n\x0b\n\x04\x05\0\x02\x01\x12\x03X\x02\x13\n\x0c\
    \n\x05\x05\0\x02\x01\x01\x12\x03X\x02\x0e\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03X\x11\x12\n\x0b\n\x04\x05\0\x02\x02\x12\x03Y\x02\x1a\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03Y\x02\x15\n\x0c\n\x05\x05\0\x02\x02\x02\x12\
    \x03Y\x18\x19\n\x0b\n\x04\x05\0\x02\x03\x12\x03Z\x02\x13\n\x0c\n\x05\x05\
    \0\x02\x03\x01\x12\x03Z\x02\x0e\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03Z\
    \x11\x12\n\x0b\n\x04\x05\0\x02\x04\x12\x03[\x02\x14\n\x0c\n\x05\x05\0\
    \x02\x04\x01\x12\x03[\x02\x0f\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03[\x12\
    \x13\n\n\n\x02\x04\x05\x12\x04^\0v\x01\n\n\n\x03\x04\x05\x01\x12\x03^\
    \x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03_\x02\x15\n\x0c\n\x05\x04\x05\
    \x02\0\x05\x12\x03_\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03_\t\x10\
    \n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03_\x13\x14\n\x0b\n\x04\x04\x05\x02\
    \x01\x12\x03`\x02\x16\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03`\x02\x08\n\
    \x0c\n\x05\x04\x05\x02\x01\x01\x12\x03`\t\x11\n\x0c\n\x05\x04\x05\x02\
    \x01\x03\x12\x03`\x14\x15\n\x0b\n\x04\x04\x05\x02\x02\x12\x03a\x02\x16\n\
    \x0c\n\x05\x04\x05\x02\x02\x05\x12\x03a\x02\x08\n\x0c\n\x05\x04\x05\x02\
    \x02\x01\x12\x03a\t\x11\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03a\x14\x15\
    \n\x0b\n\x04\x04\x05\x02\x03\x12\x03b\x02\x17\n\x0c\n\x05\x04\x05\x02\
    \x03\x05\x12\x03b\x02\x08\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03b\t\x12\
    \n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03b\x15\x16\n\x0b\n\x04\x04\x05\
    \x02\x04\x12\x03c\x02!\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03c\x02\x07\
    \n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03c\x08\x1c\n\x0c\n\x05\x04\x05\
    \x02\x04\x03\x12\x03c\x1f\x20\n\x0c\n\x04\x04\x05\x02\x05\x12\x04d\x02i\
    \x04\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03d\x02\x08\n\x0c\n\x05\x04\
    \x05\x02\x05\x01\x12\x03d\t\x12\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03d\
    \x15\x16\n\r\n\x05\x04\x05\x02\x05\x08\x12\x04d\x17i\x03\n\x0f\n\x08\x04\
    \x05\x02\x05\x08\xee\xfb\x03\x12\x03e\x063\n\x0f\n\x08\x04\x05\x02\x05\
    \x08\xeb\xfb\x03\x12\x03f\x06G\n\x0f\n\x08\x04\x05\x02\x05\x08\xe9\xfb\
    \x03\x12\x03g\x06$\n\x0f\n\x08\x04\x05\x02\x05\x08\xed\xfb\x03\x12\x03h\
    \x06'\n\x0b\n\x04\x04\x05\x02\x06\x12\x03j\x02\x20\n\x0c\n\x05\x04\x05\
    \x02\x06\x06\x12\x03j\x02\x10\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03j\
    \x11\x1b\n\x0c\n\x05\x04\x05\x02\x06\x03\x12\x03j\x1e\x1f\nL\n\x04\x04\
    \x05\x02\x07\x12\x04l\x02o/\x1a>\x20expirationTime\x20is\x20only\x20vali\
    d\x20iff\x20orderType\x20==\x20GOOD_TIL_TIME.\n\n\x0c\n\x05\x04\x05\x02\
    \x07\x06\x12\x03l\x02\x1b\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03l\x1c+\
    \n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03l./\n\r\n\x05\x04\x05\x02\x07\
    \x08\x12\x04l0o.\n\x0f\n\x08\x04\x05\x02\x07\x08\xf2\xfb\x03\x12\x03m-G\
    \n\x0f\n\x08\x04\x05\x02\x07\x08\xe9\xfb\x03\x12\x03n-H\n\x0c\n\x04\x04\
    \x05\x02\x08\x12\x04p\x02u\x19\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x03p\
    \x02\x08\n\x0c\n\x05\x04\x05\x02\x08\x01\x12\x03p\t\x17\n\x0c\n\x05\x04\
    \x05\x02\x08\x03\x12\x03p\x1a\x1c\n\r\n\x05\x04\x05\x02\x08\x08\x12\x04p\
    \x1du\x18\n\x0f\n\x08\x04\x05\x02\x08\x08\xee\xfb\x03\x12\x03q\x17I\n\
    \x0f\n\x08\x04\x05\x02\x08\x08\xeb\xfb\x03\x12\x03r\x17X\n\x0f\n\x08\x04\
    \x05\x02\x08\x08\xe9\xfb\x03\x12\x03s\x174\n\x0f\n\x08\x04\x05\x02\x08\
    \x08\xed\xfb\x03\x12\x03t\x17=\n\x0b\n\x02\x04\x06\x12\x05x\0\x8b\x01\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03x\x08\"\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03y\x02\x18\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03y\x02\x08\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03y\t\x13\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03y\
    \x16\x17\n>\n\x04\x04\x06\x02\x01\x12\x05{\x02\x80\x01/\x1a/\x20Total\
    \x20amount\x20of\x20coin\x20used\x20for\x20the\x20limit\x20order\n\n\x0c\
    \n\x05\x04\x06\x02\x01\x06\x12\x03{\x02\x1a\n\x0c\n\x05\x04\x06\x02\x01\
    \x01\x12\x03{\x1b\"\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03{%&\n\x0e\n\
    \x05\x04\x06\x02\x01\x08\x12\x05{'\x80\x01.\n\x0f\n\x08\x04\x06\x02\x01\
    \x08\xee\xfb\x03\x12\x03|'R\n\x0f\n\x08\x04\x06\x02\x01\x08\xe9\xfb\x03\
    \x12\x03}-I\n\x0f\n\x08\x04\x06\x02\x01\x08\xeb\xfb\x03\x12\x03~-o\n\x0f\
    \n\x08\x04\x06\x02\x01\x08\xed\xfb\x03\x12\x03\x7f-L\n\xaa\x02\n\x04\x04\
    \x06\x02\x02\x12\x06\x84\x01\x02\x89\x01*\x1a\x99\x02\x20Total\x20amount\
    \x20of\x20coin\x20received\x20from\x20the\x20taker\x20portion\x20of\x20t\
    he\x20limit\x20order\n\x20This\x20is\x20the\x20amount\x20of\x20coin\x20i\
    mmediately\x20available\x20in\x20the\x20users\x20account\x20after\x20exe\
    cuting\x20the\n\x20limit\x20order.\x20It\x20does\x20not\x20include\x20an\
    y\x20future\x20proceeds\x20from\x20the\x20maker\x20portion\x20which\x20w\
    ill\x20have\x20withdrawn\x20in\x20the\x20future\n\n\r\n\x05\x04\x06\x02\
    \x02\x06\x12\x04\x84\x01\x02\x1a\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \x84\x01\x1b)\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x84\x01,-\n\x0f\n\
    \x05\x04\x06\x02\x02\x08\x12\x06\x84\x01.\x89\x01)\n\x10\n\x08\x04\x06\
    \x02\x02\x08\xee\xfb\x03\x12\x04\x85\x01-_\n\x10\n\x08\x04\x06\x02\x02\
    \x08\xe9\xfb\x03\x12\x04\x86\x01(D\n\x10\n\x08\x04\x06\x02\x02\x08\xeb\
    \xfb\x03\x12\x04\x87\x01(j\n\x10\n\x08\x04\x06\x02\x02\x08\xed\xfb\x03\
    \x12\x04\x88\x01-S\n\x0c\n\x02\x04\x07\x12\x06\x8d\x01\0\x90\x01\x01\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\x8d\x01\x08#\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\x8e\x01\x02\x15\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x8e\x01\x02\
    \x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x8e\x01\t\x10\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\x8e\x01\x13\x14\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\
    \x8f\x01\x02\x19\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x8f\x01\x02\x08\n\
    \r\n\x05\x04\x07\x02\x01\x01\x12\x04\x8f\x01\t\x14\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\x8f\x01\x17\x18\n\x0c\n\x02\x04\x08\x12\x06\x92\x01\0\
    \x93\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\x92\x01\x08+\n\x0c\n\x02\
    \x04\t\x12\x06\x95\x01\0\x98\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x95\
    \x01\x08\x1b\n\x0c\n\x04\x04\t\x02\0\x12\x04\x96\x01\x02\x15\n\r\n\x05\
    \x04\t\x02\0\x05\x12\x04\x96\x01\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\x96\x01\t\x10\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x96\x01\x13\x14\n\
    \x0c\n\x04\x04\t\x02\x01\x12\x04\x97\x01\x02\x19\n\r\n\x05\x04\t\x02\x01\
    \x05\x12\x04\x97\x01\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x97\x01\
    \t\x14\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x97\x01\x17\x18\n\x0c\n\x02\
    \x04\n\x12\x06\x9a\x01\0\x9b\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x9a\
    \x01\x08#\n\x0c\n\x02\x04\x0b\x12\x06\x9d\x01\0\x9f\x01\x01\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\x9d\x01\x08\x15\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\
    \x9e\x01\x02\x1b\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x9e\x01\x02\n\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\x9e\x01\x0b\x11\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x9e\x01\x12\x16\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x9e\x01\
    \x19\x1a\n\x0c\n\x02\x04\x0c\x12\x06\xa1\x01\0\xb4\x01\x01\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xa1\x01\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\
    \xa2\x01\x02\x15\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xa2\x01\x02\x08\n\r\
    \n\x05\x04\x0c\x02\0\x01\x12\x04\xa2\x01\t\x10\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xa2\x01\x13\x14\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xa3\x01\
    \x02\x16\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa3\x01\x02\x08\n\r\n\x05\
    \x04\x0c\x02\x01\x01\x12\x04\xa3\x01\t\x11\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\xa3\x01\x14\x15\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xa4\x01\x02\
    $\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xa4\x01\x02\n\n\r\n\x05\x04\x0c\
    \x02\x02\x06\x12\x04\xa4\x01\x0b\x18\n\r\n\x05\x04\x0c\x02\x02\x01\x12\
    \x04\xa4\x01\x19\x1f\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xa4\x01\"#\n\
    \x0e\n\x04\x04\x0c\x02\x03\x12\x06\xa5\x01\x02\xaa\x01\x19\n\r\n\x05\x04\
    \x0c\x02\x03\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x03\x01\
    \x12\x04\xa5\x01\t\x12\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xa5\x01\x15\
    \x16\n\x0f\n\x05\x04\x0c\x02\x03\x08\x12\x06\xa5\x01\x17\xaa\x01\x18\n\
    \x10\n\x08\x04\x0c\x02\x03\x08\xee\xfb\x03\x12\x04\xa6\x01\x17D\n\x10\n\
    \x08\x04\x0c\x02\x03\x08\xeb\xfb\x03\x12\x04\xa7\x01\x17X\n\x10\n\x08\
    \x04\x0c\x02\x03\x08\xe9\xfb\x03\x12\x04\xa8\x01\x175\n\x10\n\x08\x04\
    \x0c\x02\x03\x08\xed\xfb\x03\x12\x04\xa9\x01\x178\n\x0e\n\x04\x04\x0c\
    \x02\x04\x12\x06\xab\x01\x02\xb0\x01\x1f\n\r\n\x05\x04\x0c\x02\x04\x05\
    \x12\x04\xab\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xab\x01\t\
    \x19\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xab\x01\x1c\x1d\n\x0f\n\x05\
    \x04\x0c\x02\x04\x08\x12\x06\xab\x01\x1e\xb0\x01\x1e\n\x10\n\x08\x04\x0c\
    \x02\x04\x08\xee\xfb\x03\x12\x04\xac\x01\x1dQ\n\x10\n\x08\x04\x0c\x02\
    \x04\x08\xeb\xfb\x03\x12\x04\xad\x01\x1di\n\x10\n\x08\x04\x0c\x02\x04\
    \x08\xe9\xfb\x03\x12\x04\xae\x01\x1d;\n\x10\n\x08\x04\x0c\x02\x04\x08\
    \xed\xfb\x03\x12\x04\xaf\x01\x1dE\n\x9c\x01\n\x04\x04\x0c\x02\x05\x12\
    \x04\xb3\x01\x02\x1b\x1a\x8d\x01\x20If\x20pickBestRoute\x20==\x20true\
    \x20then\x20all\x20routes\x20are\x20run\x20and\x20the\x20route\x20with\
    \x20the\x20best\x20price\x20is\x20chosen\n\x20otherwise,\x20the\x20first\
    \x20succesful\x20route\x20is\x20used.\n\n\r\n\x05\x04\x0c\x02\x05\x05\
    \x12\x04\xb3\x01\x02\x06\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xb3\x01\
    \x07\x16\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xb3\x01\x19\x1a\n\x0c\n\
    \x02\x04\r\x12\x06\xb6\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\
    \xb6\x01\x08\x1f\n\x0e\n\x04\x04\r\x02\0\x12\x06\xb7\x01\x02\xbb\x01*\n\
    \r\n\x05\x04\r\x02\0\x06\x12\x04\xb7\x01\x02\x1a\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\xb7\x01\x1b#\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb7\x01&'\n\
    \x0f\n\x05\x04\r\x02\0\x08\x12\x06\xb7\x01(\xbb\x01)\n\x10\n\x08\x04\r\
    \x02\0\x08\xe9\xfb\x03\x12\x04\xb8\x01(D\n\x10\n\x08\x04\r\x02\0\x08\xeb\
    \xfb\x03\x12\x04\xb9\x01(j\n\x10\n\x08\x04\r\x02\0\x08\xed\xfb\x03\x12\
    \x04\xba\x01(H\n\x0c\n\x02\x04\x0e\x12\x06\xbe\x01\0\xc7\x01\x01\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\xbe\x01\x08\x17\n\x0b\n\x03\x04\x0e\x07\x12\x04\
    \xbf\x01\x02.\n\x0f\n\x07\x04\x0e\x07\xf1\x8c\xa6\x05\x12\x04\xbf\x01\
    \x02.\n\x0b\n\x03\x04\x0e\x07\x12\x04\xc0\x01\x02.\n\x10\n\x08\x04\x0e\
    \x07\xf0\x8c\xa6\x05\0\x12\x04\xc0\x01\x02.\nC\n\x04\x04\x0e\x02\0\x12\
    \x04\xc3\x01\x02J\x1a5\x20Authority\x20is\x20the\x20address\x20of\x20the\
    \x20governance\x20account.\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xc3\x01\
    \x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xc3\x01\t\x12\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\xc3\x01\x15\x16\n\r\n\x05\x04\x0e\x02\0\x08\x12\
    \x04\xc3\x01\x17I\n\x10\n\x08\x04\x0e\x02\0\x08\xca\xd6\x05\x12\x04\xc3\
    \x01\x19G\n8\n\x04\x04\x0e\x02\x01\x12\x06\xc5\x01\x02\xc6\x01D\x1a(\x20\
    NOTE:\x20All\x20parameters\x20must\x20be\x20supplied.\n\n\r\n\x05\x04\
    \x0e\x02\x01\x06\x12\x04\xc5\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\
    \x12\x04\xc5\x01\t\x0f\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xc5\x01\x12\
    \x13\n\r\n\x05\x04\x0e\x02\x01\x08\x12\x04\xc6\x01\x04C\n\x10\n\x08\x04\
    \x0e\x02\x01\x08\xe9\xfb\x03\x12\x04\xc6\x01\x06\"\n\x11\n\t\x04\x0e\x02\
    \x01\x08\xf5\x8c\xa6\x05\x12\x04\xc6\x01$A\n|\n\x02\x04\x0f\x12\x04\xcd\
    \x01\0\"\x1ap\x20MsgUpdateParamsResponse\x20defines\x20the\x20response\
    \x20structure\x20for\x20executing\x20a\n\x20MsgUpdateParams\x20message.\
    \n\n\x20Since:\x200.47\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xcd\x01\x08\x1f\
    b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(super::coin::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::amino::file_descriptor().clone());
            deps.push(super::params::file_descriptor().clone());
            deps.push(super::msg::file_descriptor().clone());
            deps.push(super::cosmos::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(DepositOptions::generated_message_descriptor_data());
            messages.push(MsgDeposit::generated_message_descriptor_data());
            messages.push(MsgDepositResponse::generated_message_descriptor_data());
            messages.push(MsgWithdrawal::generated_message_descriptor_data());
            messages.push(MsgWithdrawalResponse::generated_message_descriptor_data());
            messages.push(MsgPlaceLimitOrder::generated_message_descriptor_data());
            messages.push(MsgPlaceLimitOrderResponse::generated_message_descriptor_data());
            messages.push(MsgWithdrawFilledLimitOrder::generated_message_descriptor_data());
            messages.push(MsgWithdrawFilledLimitOrderResponse::generated_message_descriptor_data());
            messages.push(MsgCancelLimitOrder::generated_message_descriptor_data());
            messages.push(MsgCancelLimitOrderResponse::generated_message_descriptor_data());
            messages.push(MultiHopRoute::generated_message_descriptor_data());
            messages.push(MsgMultiHopSwap::generated_message_descriptor_data());
            messages.push(MsgMultiHopSwapResponse::generated_message_descriptor_data());
            messages.push(MsgUpdateParams::generated_message_descriptor_data());
            messages.push(MsgUpdateParamsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(LimitOrderType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
